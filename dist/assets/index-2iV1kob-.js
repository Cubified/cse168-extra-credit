var st=Object.defineProperty;var ct=(e,t,n)=>t in e?st(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n;var xe=(e,t,n)=>(ct(e,typeof t!="symbol"?t+"":t,n),n);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const c of document.querySelectorAll('link[rel="modulepreload"]'))a(c);new MutationObserver(c=>{for(const l of c)if(l.type==="childList")for(const f of l.addedNodes)f.tagName==="LINK"&&f.rel==="modulepreload"&&a(f)}).observe(document,{childList:!0,subtree:!0});function n(c){const l={};return c.integrity&&(l.integrity=c.integrity),c.referrerPolicy&&(l.referrerPolicy=c.referrerPolicy),c.crossOrigin==="use-credentials"?l.credentials="include":c.crossOrigin==="anonymous"?l.credentials="omit":l.credentials="same-origin",l}function a(c){if(c.ep)return;c.ep=!0;const l=n(c);fetch(c.href,l)}})();function S(){}function ot(e){return e()}function De(){return Object.create(null)}function ue(e){e.forEach(ot)}function at(e){return typeof e=="function"}function lt(e,t){return e!=e?t==t:e!==t||e&&typeof e=="object"||typeof e=="function"}let le;function Q(e,t){return e===t?!0:(le||(le=document.createElement("a")),le.href=t,e===le.href)}function dt(e){return Object.keys(e).length===0}function r(e,t){e.appendChild(t)}function W(e,t,n){e.insertBefore(t,n||null)}function U(e){e.parentNode&&e.parentNode.removeChild(e)}function de(e,t){for(let n=0;n<e.length;n+=1)e[n]&&e[n].d(t)}function s(e){return document.createElement(e)}function ut(e){return document.createTextNode(e)}function u(){return ut(" ")}function d(e,t,n){n==null?e.removeAttribute(t):e.getAttribute(t)!==n&&e.setAttribute(t,n)}function ht(e){return Array.from(e.childNodes)}let ke;function V(e){ke=e}const B=[],Ge=[];let N=[];const Je=[],mt=Promise.resolve();let $e=!1;function ft(){$e||($e=!0,mt.then(it))}function Te(e){N.push(e)}const Ce=new Set;let P=0;function it(){if(P!==0)return;const e=ke;do{try{for(;P<B.length;){const t=B[P];P++,V(t),pt(t.$$)}}catch(t){throw B.length=0,P=0,t}for(V(null),B.length=0,P=0;Ge.length;)Ge.pop()();for(let t=0;t<N.length;t+=1){const n=N[t];Ce.has(n)||(Ce.add(n),n())}N.length=0}while(B.length);for(;Je.length;)Je.pop()();$e=!1,Ce.clear(),V(e)}function pt(e){if(e.fragment!==null){e.update(),ue(e.before_update);const t=e.dirty;e.dirty=[-1],e.fragment&&e.fragment.p(e.ctx,t),e.after_update.forEach(Te)}}function gt(e){const t=[],n=[];N.forEach(a=>e.indexOf(a)===-1?t.push(a):n.push(a)),n.forEach(a=>a()),N=t}const bt=new Set;function _t(e,t){e&&e.i&&(bt.delete(e),e.i(t))}function M(e){return(e==null?void 0:e.length)!==void 0?e:Array.from(e)}function vt(e,t,n){const{fragment:a,after_update:c}=e.$$;a&&a.m(t,n),Te(()=>{const l=e.$$.on_mount.map(ot).filter(at);e.$$.on_destroy?e.$$.on_destroy.push(...l):ue(l),e.$$.on_mount=[]}),c.forEach(Te)}function wt(e,t){const n=e.$$;n.fragment!==null&&(gt(n.after_update),ue(n.on_destroy),n.fragment&&n.fragment.d(t),n.on_destroy=n.fragment=null,n.ctx=[])}function yt(e,t){e.$$.dirty[0]===-1&&(B.push(e),ft(),e.$$.dirty.fill(0)),e.$$.dirty[t/31|0]|=1<<t%31}function xt(e,t,n,a,c,l,f=null,p=[-1]){const m=ke;V(e);const h=e.$$={fragment:null,ctx:[],props:l,update:S,not_equal:c,bound:De(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(t.context||(m?m.$$.context:[])),callbacks:De(),dirty:p,skip_bound:!1,root:t.target||m.$$.root};f&&f(h.root);let g=!1;if(h.ctx=n?n(e,t.props||{},(y,R,...A)=>{const F=A.length?A[0]:R;return h.ctx&&c(h.ctx[y],h.ctx[y]=F)&&(!h.skip_bound&&h.bound[y]&&h.bound[y](F),g&&yt(e,y)),R}):[],h.update(),g=!0,ue(h.before_update),h.fragment=a?a(h.ctx):!1,t.target){if(t.hydrate){const y=ht(t.target);h.fragment&&h.fragment.l(y),y.forEach(U)}else h.fragment&&h.fragment.c();t.intro&&_t(e.$$.fragment),vt(e,t.target,t.anchor),it()}V(m)}class Ct{constructor(){xe(this,"$$");xe(this,"$$set")}$destroy(){wt(this,1),this.$destroy=S}$on(t,n){if(!at(n))return S;const a=this.$$.callbacks[t]||(this.$$.callbacks[t]=[]);return a.push(n),()=>{const c=a.indexOf(n);c!==-1&&a.splice(c,1)}}$set(t){this.$$set&&!dt(t)&&(this.$$.skip_bound=!0,this.$$set(t),this.$$.skip_bound=!1)}}const $t="4";typeof window<"u"&&(window.__svelte||(window.__svelte={v:new Set})).v.add($t);function Ye(e,t,n){const a=e.slice();return a[4]=t[n].desc,a[5]=t[n].img,a[7]=n,a}function ze(e,t,n){const a=e.slice();return a[4]=t[n].desc,a[5]=t[n].img,a[7]=n,a}function Xe(e,t,n){const a=e.slice();return a[4]=t[n].desc,a[5]=t[n].img,a[7]=n,a}function Ze(e,t,n){const a=e.slice();return a[4]=t[n].desc,a[5]=t[n].img,a[7]=n,a}function et(e){let t,n,a,c,l,f=e[4]+"",p;return{c(){t=s("div"),n=s("img"),c=u(),l=s("p"),p=u(),Q(n.src,a=K+"/hw1_168/"+e[5])||d(n,"src",a),d(n,"alt","HW1 demo "+e[7]),d(t,"class","item nonsquare")},m(m,h){W(m,t,h),r(t,n),r(t,c),r(t,l),l.innerHTML=f,r(t,p)},p:S,d(m){m&&U(t)}}}function tt(e){let t,n,a,c,l,f=e[4]+"",p;return{c(){t=s("div"),n=s("img"),c=u(),l=s("p"),p=u(),Q(n.src,a=K+"/hw4/"+e[5])||d(n,"src",a),d(n,"alt","HW4 demo "+e[7]),d(t,"class","item nonsquare")},m(m,h){W(m,t,h),r(t,n),r(t,c),r(t,l),l.innerHTML=f,r(t,p)},p:S,d(m){m&&U(t)}}}function nt(e){let t,n,a,c,l,f=e[4]+"",p;return{c(){t=s("div"),n=s("img"),c=u(),l=s("p"),p=u(),Q(n.src,a=K+"/hw3/"+e[5])||d(n,"src",a),d(n,"alt","HW3 demo "+e[7]),d(t,"class","item nonsquare")},m(m,h){W(m,t,h),r(t,n),r(t,c),r(t,l),l.innerHTML=f,r(t,p)},p:S,d(m){m&&U(t)}}}function rt(e){let t,n,a,c,l,f=e[4]+"",p;return{c(){t=s("div"),n=s("img"),c=u(),l=s("p"),p=u(),Q(n.src,a=K+"/hw2/"+e[5])||d(n,"src",a),d(n,"alt","HW2 demo "+e[7]),d(t,"class","item")},m(m,h){W(m,t,h),r(t,n),r(t,c),r(t,l),l.innerHTML=f,r(t,p)},p:S,d(m){m&&U(t)}}}function Tt(e){let t,n,a,c,l,f,p,m,h,g,y,R,A,F,D,G,J,Se,he,Me,Y,Ae,x,me,He,fe,je,H,z,Le,X,Z,Ee,pe,Ie,ee,Oe,C,ge,qe,be,Pe,j,te,Be,ne,re,Ne,_e,Ue,oe,Re,$,ve,Fe,we,Ve,L,ae,Qe,ie,se,We,ye,Ke,ce,E=M(e[3]),b=[];for(let i=0;i<E.length;i+=1)b[i]=et(Ze(e,E,i));let I=M(e[2]),_=[];for(let i=0;i<I.length;i+=1)_[i]=tt(Xe(e,I,i));let O=M(e[1]),v=[];for(let i=0;i<O.length;i+=1)v[i]=nt(ze(e,O,i));let q=M(e[0]),w=[];for(let i=0;i<q.length;i+=1)w[i]=rt(Ye(e,q,i));return{c(){t=s("main"),n=s("div"),a=s("img"),l=u(),f=s("h1"),f.textContent="CSE 168 Extra Credit Site",p=u(),m=s("h3"),m.innerHTML='Andrew Russell (<a href="mailto:alrussell@ucsd.edu">alrussell@ucsd.edu</a>)',h=u(),g=s("div"),y=s("h1"),y.innerHTML="Homework 1:<br/>Ray Tracer Improvements",R=u(),A=s("p"),A.textContent="I improved my ray tracer from CSE 167 by adding antialiasing, area lights, depth-of-field, texture mapping, and .OBJ file parsing.",F=u(),D=s("div"),G=s("div"),J=s("div");for(let i=0;i<b.length;i+=1)b[i].c();Se=u(),he=s("h4"),he.textContent="Sources:",Me=u(),Y=s("p"),Y.innerHTML=`<a href="https://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf">Triangle intersection algorithm</a>
       | 
      <a href="https://math.stackexchange.com/a/128999">Triangle area formula</a>
       | 
      <a href="https://jacco.ompf2.com/2022/04/13/how-to-build-a-bvh-part-1-basics">BVH calculation</a>
       | 
      <a href="https://tavianator.com/2011/ray_box.html">AABB intersection test</a>
       | 
      <a href="https://en.wikipedia.org/wiki/Wavefront_.obj_file">.OBJ file format</a>
       | 
      <a href="https://github.com/nothings/stb/blob/master/stb_image_write.h"><code>stb_image_write</code></a>
       | 
      <a href="https://github.com/nothings/stb/blob/master/stb_image.h"><code>stb_image</code></a>`,Ae=u(),x=s("div"),me=s("h1"),me.innerHTML="CSE 167 Final Project:<br/>Interactive, Real-Time Ray Tracer in the Terminal",He=u(),fe=s("p"),fe.innerHTML='I extended my raytracer by reading and writing <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">ANSI escape sequences</a> to standard input and standard output.  Coupled with the performance gains from my bounding volume hierarchy and the addition of multithreading, this allows for interactive raytracing in real-time.',je=u(),H=s("div"),z=s("div"),z.innerHTML='<iframe src="https://www.youtube.com/embed/F71dgYAOl-I?si=9SXhBIqVycQj7vqg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>',Le=u(),X=s("div"),Z=s("div");for(let i=0;i<_.length;i+=1)_[i].c();Ee=u(),pe=s("h4"),pe.textContent="Sources:",Ie=u(),ee=s("p"),ee.innerHTML=`<a href="https://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf">Triangle intersection algorithm</a>
       | 
      <a href="https://math.stackexchange.com/a/128999">Triangle area formula</a>
       | 
      <a href="https://jacco.ompf2.com/2022/04/13/how-to-build-a-bvh-part-1-basics">BVH calculation</a>
       | 
      <a href="https://tavianator.com/2011/ray_box.html">AABB intersection test</a>
       | 
      <a href="https://github.com/nothings/stb/blob/master/stb_image_write.h"><code>stb_image_write</code></a>`,Oe=u(),C=s("div"),ge=s("h1"),ge.textContent="CSE 167 Homework 3: Lathe Editor",qe=u(),be=s("p"),be.textContent="My project extends Homework 3 by generating a solid of revolution (lathe) from the user's curves.  It also generates smooth vertex normals, demonstrated by a cubemap for reflections.  Users can also add multiple curves and change their colors, in order to create complex compound shapes.",Pe=u(),j=s("div"),te=s("div"),te.innerHTML='<iframe src="https://www.youtube.com/embed/aVaHUaQEquQ?si=9SXhBIqVycQj7vqg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>',Be=u(),ne=s("div"),re=s("div");for(let i=0;i<v.length;i+=1)v[i].c();Ne=u(),_e=s("h4"),_e.textContent="Sources and Asset Credits:",Ue=u(),oe=s("p"),oe.innerHTML=`<a href="https://stackoverflow.com/questions/7904281/opengl-rotate-a-curve-about-the-y-axis">Solid of Revolution Generation</a>
       | 
      <a href="https://computergraphics.stackexchange.com/questions/4031/programmatically-generating-vertex-normals">Vertex Normals Calculation</a>
       | 
      <a href="https://www.humus.name/index.php?page=Textures&amp;start=0">Cubemap Image</a>`,Re=u(),$=s("div"),ve=s("h1"),ve.textContent="CSE 167 Homework 2: Scene Animator",Fe=u(),we=s("p"),we.textContent="My project extends Homework 2 by adding more interactivity, turning the scene viewer into a scene editor.  Users can select a cubemap, transform individual objects, apply a texture to an object, add keyframes, and play back animations.  It also adds a custom scene, built to show off these features.",Ve=u(),L=s("div"),ae=s("div"),ae.innerHTML='<iframe src="https://www.youtube.com/embed/l4iw-qttC9c?si=9SXhBIqVycQj7vqg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>',Qe=u(),ie=s("div"),se=s("div");for(let i=0;i<w.length;i+=1)w[i].c();We=u(),ye=s("h4"),ye.textContent="Sources and Asset Credits:",Ke=u(),ce=s("p"),ce.innerHTML=`<a href="https://learnopengl.com/Advanced-OpenGL/Cubemaps">Learn OpenGL: Cubemaps</a>
       | 
      <a href="https://www.humus.name/index.php?page=Textures&amp;start=0">Cubemap Images</a>
       | 
      <a href="https://architextures.org/textures/category/stone">Limestone Texture</a>
       | 
      <a href="https://easings.net/#easeInOutQuad">Easing Function Formula</a>
       | 
      I used <a href="https://glm.g-truc.net/0.9.3/api/a00178.html"><code>glm::interpolate</code></a> to achieve interpolation between keyframes.`,Q(a.src,c=K+"/utah.png")||d(a,"src",c),d(a,"alt","Utah Teapot"),d(n,"class","masthead"),d(G,"class","scroller"),d(D,"class","assignment"),d(Y,"class","spread"),d(g,"class","content"),d(z,"class","video"),d(X,"class","scroller"),d(H,"class","assignment"),d(ee,"class","spread"),d(x,"class","content"),d(te,"class","video"),d(ne,"class","scroller"),d(j,"class","assignment"),d(oe,"class","spread"),d(C,"class","content"),d(ae,"class","video"),d(ie,"class","scroller"),d(L,"class","assignment"),d(ce,"class","spread"),d($,"class","content")},m(i,k){W(i,t,k),r(t,n),r(n,a),r(n,l),r(n,f),r(n,p),r(n,m),r(t,h),r(t,g),r(g,y),r(g,R),r(g,A),r(g,F),r(g,D),r(D,G),r(G,J);for(let o=0;o<b.length;o+=1)b[o]&&b[o].m(J,null);r(g,Se),r(g,he),r(g,Me),r(g,Y),r(t,Ae),r(t,x),r(x,me),r(x,He),r(x,fe),r(x,je),r(x,H),r(H,z),r(H,Le),r(H,X),r(X,Z);for(let o=0;o<_.length;o+=1)_[o]&&_[o].m(Z,null);r(x,Ee),r(x,pe),r(x,Ie),r(x,ee),r(t,Oe),r(t,C),r(C,ge),r(C,qe),r(C,be),r(C,Pe),r(C,j),r(j,te),r(j,Be),r(j,ne),r(ne,re);for(let o=0;o<v.length;o+=1)v[o]&&v[o].m(re,null);r(C,Ne),r(C,_e),r(C,Ue),r(C,oe),r(t,Re),r(t,$),r($,ve),r($,Fe),r($,we),r($,Ve),r($,L),r(L,ae),r(L,Qe),r(L,ie),r(ie,se);for(let o=0;o<w.length;o+=1)w[o]&&w[o].m(se,null);r($,We),r($,ye),r($,Ke),r($,ce)},p(i,[k]){if(k&8){E=M(i[3]);let o;for(o=0;o<E.length;o+=1){const T=Ze(i,E,o);b[o]?b[o].p(T,k):(b[o]=et(T),b[o].c(),b[o].m(J,null))}for(;o<b.length;o+=1)b[o].d(1);b.length=E.length}if(k&4){I=M(i[2]);let o;for(o=0;o<I.length;o+=1){const T=Xe(i,I,o);_[o]?_[o].p(T,k):(_[o]=tt(T),_[o].c(),_[o].m(Z,null))}for(;o<_.length;o+=1)_[o].d(1);_.length=I.length}if(k&2){O=M(i[1]);let o;for(o=0;o<O.length;o+=1){const T=ze(i,O,o);v[o]?v[o].p(T,k):(v[o]=nt(T),v[o].c(),v[o].m(re,null))}for(;o<v.length;o+=1)v[o].d(1);v.length=O.length}if(k&1){q=M(i[0]);let o;for(o=0;o<q.length;o+=1){const T=Ye(i,q,o);w[o]?w[o].p(T,k):(w[o]=rt(T),w[o].c(),w[o].m(se,null))}for(;o<w.length;o+=1)w[o].d(1);w.length=q.length}},i:S,o:S,d(i){i&&U(t),de(b,i),de(_,i),de(v,i),de(w,i)}}}const K="/cse168-extra-credit";function kt(e){return[[{desc:"<b>Custom Scene</b><br>Use <code>extra_credit_scene.txt</code> to view a custom scene built with cubemaps and reflections in mind.",img:"custom_scene.png"},{desc:"<b>Cubemaps</b>:<br>Press <code>c</code> to switch between cubemaps.",img:"cubemaps.png"},{desc:"<b>Keyframes</b>:<br>Press <code>space</code> in edit mode to add a keyframe, then <code>e</code> to exit edit mode and play back the animation.",img:"keyframes.gif"},{desc:"<b>Edit mode</b>:<br>Press <code>e</code> to enter edit mode, then <code>tab/shift+tab</code> to focus different objects in the scene.",img:"edit_mode.png"},{desc:"<b>Scene editing</b>:<br>Press <code>x/y/z</code> to select an axis, <code>t/r/s</code> to select an operation, and <code>up/down</code> to modify the current object.",img:"scene_editing.png"},{desc:"<b>Mouse orbit</b>:<br>Use the mouse to orbit the scene.",img:"mouse_orbit.png"},{desc:"<b>Reflections</b>:<br>Use the <code>reflectivity</code> command to specify how much of the cubemap an object reflects.",img:"reflections.png"},{desc:"<b>Textures</b>:<br>Press <code>n</code> when in edit mode to cycle between textures for each object.",img:"textures.png"}],[{desc:"<b>Real-time Editing</b><br>Construct curves in a 2D editing window and see them converted into 3D within an interactive viewing window.",img:"lathe.png"},{desc:"<b>Multiple Curves</b><br>Press <code>1/2/3</code> to add a new curve, and <code>C</code> to clear all curves.",img:"compound.png"},{desc:"<b>Vertex Normals</b><br>Each 3D object generates per-vertex normals, capable of smoothly reflecting a cubemap image.",img:"reflect.png"},{desc:"<b>Curve Coloring</b><br>Press <code>N</code> to change a single curve's color.",img:"color.png"}],[{desc:"<b>Main Assignment: High-Performance</b><br>Capable of rendering the Stanford dragon (100,000 triangles) at 4K resolution (3840x2160 pixels) in 1.7 seconds on an M1 Macbook Air.",img:"dragon_4k.png"},{desc:"<b>Main Assignment: Acceleration Structure</b><br>Computes a bounding volume hierarchy for fast intersection tests, reducing the time to render a scene with 100,000 triangles at 4K from 10 minutes to 1.7 seconds.",img:"acceleration.png"},{desc:"<b>Main Assignment: Multithreaded</b><br>Uses <code>std::thread</code> to render each scanline in a separate thread, improving performance by approximately 10x for sufficiently complex scenes.",img:"multithreaded.png"},{desc:"<b>Extra Credit: Real-Time</b><br>Capable of rendering directly to the terminal via ANSI escape sequences in real-time.",img:"realtime.png"},{desc:"<b>Extra Credit: Interactive</b><br>Click and drag the mouse to orbit around the scene to view it from different angles.",img:"interactive.png"},{desc:"<b>Extra Credit: Resizable</b><br>Re-run the program with the terminal at different zoom levels to view the scene at different resolutions.",img:"resolution.png"}],[{desc:"<b>Acceleration Structure</b><br>Computes a bounding volume hierarchy for fast intersection tests, reducing the time to render a scene with 100,000 triangles at 4K from 10 minutes to 1.7 seconds.",img:"acceleration.png"},{desc:"<b>.OBJ File Parsing</b><br>Use the <code>obj</code> command to add a Wavefront OBJ model to the scene, with support for models that supply their own vertex normals and texture coordinates.",img:"obj.png"},{desc:"<b>Texture Mapping</b><br>Use the <code>image</code> command to set the scene's background image, and the <code>texture</code> command to set the current object's texture using a PNG file.",img:"textures.png"},{desc:"<b>Area Lights/Soft Shadows</b><br>Use the <code>area</code> command to create an area light, which randomly samples shadow rays based on the <code>shadowsamples</code> command.",img:"soft_shadows.png"},{desc:"<b>Antialiasing</b><br>Use the <code>aasamples</code> command to adjust the number of jitter-sampled rays. The first ray is always shot through the center of each pixel.",img:"antialiasing.png"},{desc:"<b>Depth-of-Field</b><br>Modify <code>focallen, aperture,</code> and <code>dofsamples</code> to adjust the lens properties for randomly-sampled depth-of-field.",img:"dof.png"},{desc:"<b>Multithreading</b><br>Uses <code>std::thread</code> to render scanlines in separate threads, improving performance by approximately 10x for sufficiently complex scenes. Adjust the <code>threads</code> command to spawn a different number of threads.",img:"multithreaded.png"}]]}class St extends Ct{constructor(t){super(),xt(this,t,kt,Tt,lt,{})}}new St({target:document.getElementById("app")});
