var jt=Object.defineProperty;var It=(e,t,n)=>t in e?jt(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n;var Ie=(e,t,n)=>(It(e,typeof t!="symbol"?t+"":t,n),n);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const c of document.querySelectorAll('link[rel="modulepreload"]'))i(c);new MutationObserver(c=>{for(const d of c)if(d.type==="childList")for(const m of d.addedNodes)m.tagName==="LINK"&&m.rel==="modulepreload"&&i(m)}).observe(document,{childList:!0,subtree:!0});function n(c){const d={};return c.integrity&&(d.integrity=c.integrity),c.referrerPolicy&&(d.referrerPolicy=c.referrerPolicy),c.crossOrigin==="use-credentials"?d.credentials="include":c.crossOrigin==="anonymous"?d.credentials="omit":d.credentials="same-origin",d}function i(c){if(c.ep)return;c.ep=!0;const d=n(c);fetch(c.href,d)}})();function A(){}function Ct(e){return e()}function mt(){return Object.create(null)}function ve(e){e.forEach(Ct)}function Tt(e){return typeof e=="function"}function St(e,t){return e!=e?t==t:e!==t||e&&typeof e=="object"||typeof e=="function"}let ge;function k(e,t){return e===t?!0:(ge||(ge=document.createElement("a")),ge.href=t,e===ge.href)}function $t(e){return Object.keys(e).length===0}function r(e,t){e.appendChild(t)}function Q(e,t,n){e.insertBefore(t,n||null)}function q(e){e.parentNode&&e.parentNode.removeChild(e)}function pe(e,t){for(let n=0;n<e.length;n+=1)e[n]&&e[n].d(t)}function a(e){return document.createElement(e)}function qt(e){return document.createTextNode(e)}function u(){return qt(" ")}function l(e,t,n){n==null?e.removeAttribute(t):e.getAttribute(t)!==n&&e.setAttribute(t,n)}function Bt(e){return Array.from(e.childNodes)}let z;function K(e){z=e}function Ot(){if(!z)throw new Error("Function called outside component initialization");return z}function Pt(e){Ot().$$.on_mount.push(e)}const V=[],Y=[];let X=[];const ht=[],Nt=Promise.resolve();let qe=!1;function Rt(){qe||(qe=!0,Nt.then(Mt))}function Be(e){X.push(e)}const $e=new Set;let G=0;function Mt(){if(G!==0)return;const e=z;do{try{for(;G<V.length;){const t=V[G];G++,K(t),Dt(t.$$)}}catch(t){throw V.length=0,G=0,t}for(K(null),V.length=0,G=0;Y.length;)Y.pop()();for(let t=0;t<X.length;t+=1){const n=X[t];$e.has(n)||($e.add(n),n())}X.length=0}while(V.length);for(;ht.length;)ht.pop()();qe=!1,$e.clear(),K(e)}function Dt(e){if(e.fragment!==null){e.update(),ve(e.before_update);const t=e.dirty;e.dirty=[-1],e.fragment&&e.fragment.p(e.ctx,t),e.after_update.forEach(Be)}}function Ut(e){const t=[],n=[];X.forEach(i=>e.indexOf(i)===-1?t.push(i):n.push(i)),n.forEach(i=>i()),X=t}const be=new Set;let Wt;function Lt(e,t){e&&e.i&&(be.delete(e),e.i(t))}function Ft(e,t,n,i){if(e&&e.o){if(be.has(e))return;be.add(e),Wt.c.push(()=>{be.delete(e),i&&(n&&e.d(1),i())}),e.o(t)}else i&&i()}function I(e){return(e==null?void 0:e.length)!==void 0?e:Array.from(e)}function Gt(e){e&&e.c()}function Ht(e,t,n){const{fragment:i,after_update:c}=e.$$;i&&i.m(t,n),Be(()=>{const d=e.$$.on_mount.map(Ct).filter(Tt);e.$$.on_destroy?e.$$.on_destroy.push(...d):ve(d),e.$$.on_mount=[]}),c.forEach(Be)}function Et(e,t){const n=e.$$;n.fragment!==null&&(Ut(n.after_update),ve(n.on_destroy),n.fragment&&n.fragment.d(t),n.on_destroy=n.fragment=null,n.ctx=[])}function Vt(e,t){e.$$.dirty[0]===-1&&(V.push(e),Rt(),e.$$.dirty.fill(0)),e.$$.dirty[t/31|0]|=1<<t%31}function kt(e,t,n,i,c,d,m=null,p=[-1]){const f=z;K(e);const h=e.$$={fragment:null,ctx:[],props:d,update:A,not_equal:c,bound:mt(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(t.context||(f?f.$$.context:[])),callbacks:mt(),dirty:p,skip_bound:!1,root:t.target||f.$$.root};m&&m(h.root);let g=!1;if(h.ctx=n?n(e,t.props||{},(_,b,...v)=>{const j=v.length?v[0]:b;return h.ctx&&c(h.ctx[_],h.ctx[_]=j)&&(!h.skip_bound&&h.bound[_]&&h.bound[_](j),g&&Vt(e,_)),b}):[],h.update(),g=!0,ve(h.before_update),h.fragment=i?i(h.ctx):!1,t.target){if(t.hydrate){const _=Bt(t.target);h.fragment&&h.fragment.l(_),_.forEach(q)}else h.fragment&&h.fragment.c();t.intro&&Lt(e.$$.fragment),Ht(e,t.target,t.anchor),Mt()}K(f)}class At{constructor(){Ie(this,"$$");Ie(this,"$$set")}$destroy(){Et(this,1),this.$destroy=A}$on(t,n){if(!Tt(n))return A;const i=this.$$.callbacks[t]||(this.$$.callbacks[t]=[]);return i.push(n),()=>{const c=i.indexOf(n);c!==-1&&i.splice(c,1)}}$set(t){this.$$set&&!$t(t)&&(this.$$.skip_bound=!0,this.$$set(t),this.$$.skip_bound=!1)}}const Xt="4";typeof window<"u"&&(window.__svelte||(window.__svelte={v:new Set})).v.add(Xt);function Qt(e){let t,n,i,c,d,m,p,f,h;return{c(){t=a("div"),n=a("div"),i=a("img"),d=u(),m=a("div"),p=u(),f=a("img"),k(i.src,c=e[0])||l(i,"src",c),l(i,"alt","Scene before TWSC denoising"),l(i,"draggable",!1),l(i,"class","svelte-1cn9k4o"),l(m,"class","edge svelte-1cn9k4o"),l(n,"class","dragger svelte-1cn9k4o"),k(f.src,h=e[1])||l(f,"src",h),l(f,"alt","Scene after TWSC denoising"),l(f,"draggable",!1),l(f,"class","svelte-1cn9k4o"),l(t,"class","image_compare svelte-1cn9k4o")},m(g,_){Q(g,t,_),r(t,n),r(n,i),r(n,d),r(n,m),e[5](m),e[6](n),r(t,p),r(t,f),e[7](t)},p(g,[_]){_&1&&!k(i.src,c=g[0])&&l(i,"src",c),_&2&&!k(f.src,h=g[1])&&l(f,"src",h)},i:A,o:A,d(g){g&&q(t),e[5](null),e[6](null),e[7](null)}}}function Kt(e,t,n){let{left:i,right:c}=t,d,m,p,f=!1;Pt(()=>{const b=v=>{const j=m.getBoundingClientRect().left;n(2,d.style.left=v-j-5+"px",d),n(4,p.style.width=v-j+"px",p)};d.addEventListener("mousedown",v=>{v.preventDefault(),f=!0}),d.addEventListener("touchstart",v=>{v.preventDefault(),f=!0}),m.addEventListener("mouseup",v=>{v.preventDefault(),f=!1}),m.addEventListener("touchend",v=>{v.preventDefault(),f=!1}),m.addEventListener("mousemove",v=>{f&&(v.preventDefault(),b(v.clientX))}),m.addEventListener("touchmove",v=>{f&&(v.preventDefault(),b(v.touches[0].clientX))}),b(m.getBoundingClientRect().left+m.offsetWidth/2)});function h(b){Y[b?"unshift":"push"](()=>{d=b,n(2,d)})}function g(b){Y[b?"unshift":"push"](()=>{p=b,n(4,p)})}function _(b){Y[b?"unshift":"push"](()=>{m=b,n(3,m)})}return e.$$set=b=>{"left"in b&&n(0,i=b.left),"right"in b&&n(1,c=b.right)},[i,c,d,m,p,h,g,_]}class Yt extends At{constructor(t){super(),kt(this,t,Kt,Qt,St,{left:0,right:1})}}function gt(e,t,n){const i=e.slice();return i[4]=t[n].desc,i[5]=t[n].img,i[7]=n,i}function pt(e,t,n){const i=e.slice();return i[4]=t[n].desc,i[5]=t[n].img,i[7]=n,i}function bt(e,t,n){const i=e.slice();return i[4]=t[n].desc,i[5]=t[n].img,i[7]=n,i}function vt(e,t,n){const i=e.slice();return i[4]=t[n].desc,i[5]=t[n].img,i[7]=n,i}function _t(e){let t,n,i,c,d,m=e[4]+"",p;return{c(){t=a("div"),n=a("img"),c=u(),d=a("p"),p=u(),k(n.src,i=$+"/hw1_168/"+e[5])||l(n,"src",i),l(n,"alt","HW1 demo "+e[7]),l(t,"class","item nonsquare")},m(f,h){Q(f,t,h),r(t,n),r(t,c),r(t,d),d.innerHTML=m,r(t,p)},p:A,d(f){f&&q(t)}}}function wt(e){let t,n,i,c,d,m=e[4]+"",p;return{c(){t=a("div"),n=a("img"),c=u(),d=a("p"),p=u(),k(n.src,i=$+"/hw4/"+e[5])||l(n,"src",i),l(n,"alt","HW4 demo "+e[7]),l(t,"class","item nonsquare")},m(f,h){Q(f,t,h),r(t,n),r(t,c),r(t,d),d.innerHTML=m,r(t,p)},p:A,d(f){f&&q(t)}}}function yt(e){let t,n,i,c,d,m=e[4]+"",p;return{c(){t=a("div"),n=a("img"),c=u(),d=a("p"),p=u(),k(n.src,i=$+"/hw3/"+e[5])||l(n,"src",i),l(n,"alt","HW3 demo "+e[7]),l(t,"class","item nonsquare")},m(f,h){Q(f,t,h),r(t,n),r(t,c),r(t,d),d.innerHTML=m,r(t,p)},p:A,d(f){f&&q(t)}}}function xt(e){let t,n,i,c,d,m=e[4]+"",p;return{c(){t=a("div"),n=a("img"),c=u(),d=a("p"),p=u(),k(n.src,i=$+"/hw2/"+e[5])||l(n,"src",i),l(n,"alt","HW2 demo "+e[7]),l(t,"class","item")},m(f,h){Q(f,t,h),r(t,n),r(t,c),r(t,d),d.innerHTML=m,r(t,p)},p:A,d(f){f&&q(t)}}}function zt(e){let t,n,i,c,d,m,p,f,h,g,_,b,v,j,Oe,Pe,_e,Ne,Re,De,B,Ue,we,We,T,ye,Fe,xe,Ge,O,J,Ve,Z,ee,Xe,Ce,Qe,te,Ke,S,Te,Ye,Se,ze,P,ne,Je,re,ie,Ze,Me,et,oe,tt,M,Le,nt,He,rt,N,ae,it,se,le,ot,Ee,at,ce,st,L,ke,lt,Ae,ct,R,de,dt,ue,fe,ut,je,ft,me,he;B=new Yt({props:{left:$+"/final/twsc_in.png",right:$+"/final/twsc_out.png"}});let D=I(e[3]),w=[];for(let s=0;s<D.length;s+=1)w[s]=_t(vt(e,D,s));let U=I(e[2]),y=[];for(let s=0;s<U.length;s+=1)y[s]=wt(bt(e,U,s));let W=I(e[1]),x=[];for(let s=0;s<W.length;s+=1)x[s]=yt(pt(e,W,s));let F=I(e[0]),C=[];for(let s=0;s<F.length;s+=1)C[s]=xt(gt(e,F,s));return{c(){t=a("main"),n=a("div"),i=a("img"),d=u(),m=a("h1"),m.textContent="CSE 168 Extra Credit Site",p=u(),f=a("h3"),f.innerHTML='Andrew Russell (<a href="mailto:alrussell@ucsd.edu">alrussell@ucsd.edu</a>)',h=u(),g=a("div"),_=a("h1"),_.innerHTML="Final Project:<br/>Modern Image Denoising",b=u(),v=a("p"),v.innerHTML='My planned final project implements the denoising algorithm proposed in the 2018 paper <a href="https://arxiv.org/abs/1807.04364">&quot;A Trilateral Weighted Sparse Coding Scheme for Real-World Image Denoising&quot; by Xu, Zhang, and Zhang</a>.',j=u(),Oe=a("br"),Pe=u(),_e=a("p"),_e.innerHTML="It is a notable algorithm because it specifically aims to reduce &quot;real-world noise,&quot; or noise patterns that occur more commonly in photos taken by physical cameras.  This is in contrast to algorithms which assume noise samples randomly from <b>additive white Gaussian noise (AWGN)</b>, a relatively simple analytical model for electron motion.  I would like to investigate <b>whether this more complex modeling of noise positively impacts image denoising in path-traced images</b>, and if so what specific parameters produce the best results.",Ne=u(),Re=a("br"),De=u(),Gt(B.$$.fragment),Ue=u(),we=a("p"),we.innerHTML="<i>This is a side-by-side comparison of the original GGX sample scene (left) and the GGX sample scene after being passed through TWSC denoising (right). Drag the divider to compare the images.</i>",We=u(),T=a("div"),ye=a("h1"),ye.innerHTML="Homework 1:<br/>Interactive Scene Editor for Ray Tracer",Fe=u(),xe=a("p"),xe.innerHTML='I improved my ray tracer from CSE 167 by adding antialiasing, area lights, depth-of-field, texture mapping, and .OBJ file parsing. Scenes are now editable in real-time using a <a href="https://github.com/ocornut/imgui">Dear Imgui</a>-based user interface.',Ge=u(),O=a("div"),J=a("div"),J.innerHTML='<iframe src="https://www.youtube.com/embed/b-tWFDPlZHQ?si=9SXhBIqVycQj7vqg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>',Ve=u(),Z=a("div"),ee=a("div");for(let s=0;s<w.length;s+=1)w[s].c();Xe=u(),Ce=a("h4"),Ce.textContent="Sources:",Qe=u(),te=a("p"),te.innerHTML=`<a href="https://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf">Triangle intersection algorithm</a>
       | 
      <a href="https://math.stackexchange.com/a/128999">Triangle area formula</a>
       | 
      <a href="https://jacco.ompf2.com/2022/04/13/how-to-build-a-bvh-part-1-basics">BVH calculation</a>
       | 
      <a href="https://tavianator.com/2011/ray_box.html">AABB intersection test</a>
       | 
      <a href="https://en.wikipedia.org/wiki/Wavefront_.obj_file">.OBJ file format</a>
       | 
      <a href="https://github.com/nothings/stb/blob/master/stb_image_write.h"><code>stb_image_write</code></a>
       | 
      <a href="https://github.com/nothings/stb/blob/master/stb_image.h"><code>stb_image</code></a>`,Ke=u(),S=a("div"),Te=a("h1"),Te.innerHTML="CSE 167 Final Project:<br/>Interactive, Real-Time Ray Tracer in the Terminal",Ye=u(),Se=a("p"),Se.innerHTML='I extended my raytracer by reading and writing <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">ANSI escape sequences</a> to standard input and standard output.  Coupled with the performance gains from my bounding volume hierarchy and the addition of multithreading, this allows for interactive raytracing in real-time.',ze=u(),P=a("div"),ne=a("div"),ne.innerHTML='<iframe src="https://www.youtube.com/embed/F71dgYAOl-I?si=9SXhBIqVycQj7vqg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>',Je=u(),re=a("div"),ie=a("div");for(let s=0;s<y.length;s+=1)y[s].c();Ze=u(),Me=a("h4"),Me.textContent="Sources:",et=u(),oe=a("p"),oe.innerHTML=`<a href="https://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf">Triangle intersection algorithm</a>
       | 
      <a href="https://math.stackexchange.com/a/128999">Triangle area formula</a>
       | 
      <a href="https://jacco.ompf2.com/2022/04/13/how-to-build-a-bvh-part-1-basics">BVH calculation</a>
       | 
      <a href="https://tavianator.com/2011/ray_box.html">AABB intersection test</a>
       | 
      <a href="https://github.com/nothings/stb/blob/master/stb_image_write.h"><code>stb_image_write</code></a>`,tt=u(),M=a("div"),Le=a("h1"),Le.textContent="CSE 167 Homework 3: Lathe Editor",nt=u(),He=a("p"),He.textContent="My project extends Homework 3 by generating a solid of revolution (lathe) from the user's curves.  It also generates smooth vertex normals, demonstrated by a cubemap for reflections.  Users can also add multiple curves and change their colors, in order to create complex compound shapes.",rt=u(),N=a("div"),ae=a("div"),ae.innerHTML='<iframe src="https://www.youtube.com/embed/aVaHUaQEquQ?si=9SXhBIqVycQj7vqg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>',it=u(),se=a("div"),le=a("div");for(let s=0;s<x.length;s+=1)x[s].c();ot=u(),Ee=a("h4"),Ee.textContent="Sources and Asset Credits:",at=u(),ce=a("p"),ce.innerHTML=`<a href="https://stackoverflow.com/questions/7904281/opengl-rotate-a-curve-about-the-y-axis">Solid of Revolution Generation</a>
       | 
      <a href="https://computergraphics.stackexchange.com/questions/4031/programmatically-generating-vertex-normals">Vertex Normals Calculation</a>
       | 
      <a href="https://www.humus.name/index.php?page=Textures&amp;start=0">Cubemap Image</a>`,st=u(),L=a("div"),ke=a("h1"),ke.textContent="CSE 167 Homework 2: Scene Animator",lt=u(),Ae=a("p"),Ae.textContent="My project extends Homework 2 by adding more interactivity, turning the scene viewer into a scene editor.  Users can select a cubemap, transform individual objects, apply a texture to an object, add keyframes, and play back animations.  It also adds a custom scene, built to show off these features.",ct=u(),R=a("div"),de=a("div"),de.innerHTML='<iframe src="https://www.youtube.com/embed/l4iw-qttC9c?si=9SXhBIqVycQj7vqg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>',dt=u(),ue=a("div"),fe=a("div");for(let s=0;s<C.length;s+=1)C[s].c();ut=u(),je=a("h4"),je.textContent="Sources and Asset Credits:",ft=u(),me=a("p"),me.innerHTML=`<a href="https://learnopengl.com/Advanced-OpenGL/Cubemaps">Learn OpenGL: Cubemaps</a>
       | 
      <a href="https://www.humus.name/index.php?page=Textures&amp;start=0">Cubemap Images</a>
       | 
      <a href="https://architextures.org/textures/category/stone">Limestone Texture</a>
       | 
      <a href="https://easings.net/#easeInOutQuad">Easing Function Formula</a>
       | 
      I used <a href="https://glm.g-truc.net/0.9.3/api/a00178.html"><code>glm::interpolate</code></a> to achieve interpolation between keyframes.`,k(i.src,c=$+"/utah.png")||l(i,"src",c),l(i,"alt","Utah Teapot"),l(n,"class","masthead"),l(g,"class","content"),l(J,"class","video"),l(Z,"class","scroller"),l(O,"class","assignment"),l(te,"class","spread"),l(T,"class","content"),l(ne,"class","video"),l(re,"class","scroller"),l(P,"class","assignment"),l(oe,"class","spread"),l(S,"class","content"),l(ae,"class","video"),l(se,"class","scroller"),l(N,"class","assignment"),l(ce,"class","spread"),l(M,"class","content"),l(de,"class","video"),l(ue,"class","scroller"),l(R,"class","assignment"),l(me,"class","spread"),l(L,"class","content")},m(s,E){Q(s,t,E),r(t,n),r(n,i),r(n,d),r(n,m),r(n,p),r(n,f),r(t,h),r(t,g),r(g,_),r(g,b),r(g,v),r(g,j),r(g,Oe),r(g,Pe),r(g,_e),r(g,Ne),r(g,Re),r(g,De),Ht(B,g,null),r(g,Ue),r(g,we),r(t,We),r(t,T),r(T,ye),r(T,Fe),r(T,xe),r(T,Ge),r(T,O),r(O,J),r(O,Ve),r(O,Z),r(Z,ee);for(let o=0;o<w.length;o+=1)w[o]&&w[o].m(ee,null);r(T,Xe),r(T,Ce),r(T,Qe),r(T,te),r(t,Ke),r(t,S),r(S,Te),r(S,Ye),r(S,Se),r(S,ze),r(S,P),r(P,ne),r(P,Je),r(P,re),r(re,ie);for(let o=0;o<y.length;o+=1)y[o]&&y[o].m(ie,null);r(S,Ze),r(S,Me),r(S,et),r(S,oe),r(t,tt),r(t,M),r(M,Le),r(M,nt),r(M,He),r(M,rt),r(M,N),r(N,ae),r(N,it),r(N,se),r(se,le);for(let o=0;o<x.length;o+=1)x[o]&&x[o].m(le,null);r(M,ot),r(M,Ee),r(M,at),r(M,ce),r(t,st),r(t,L),r(L,ke),r(L,lt),r(L,Ae),r(L,ct),r(L,R),r(R,de),r(R,dt),r(R,ue),r(ue,fe);for(let o=0;o<C.length;o+=1)C[o]&&C[o].m(fe,null);r(L,ut),r(L,je),r(L,ft),r(L,me),he=!0},p(s,[E]){if(E&8){D=I(s[3]);let o;for(o=0;o<D.length;o+=1){const H=vt(s,D,o);w[o]?w[o].p(H,E):(w[o]=_t(H),w[o].c(),w[o].m(ee,null))}for(;o<w.length;o+=1)w[o].d(1);w.length=D.length}if(E&4){U=I(s[2]);let o;for(o=0;o<U.length;o+=1){const H=bt(s,U,o);y[o]?y[o].p(H,E):(y[o]=wt(H),y[o].c(),y[o].m(ie,null))}for(;o<y.length;o+=1)y[o].d(1);y.length=U.length}if(E&2){W=I(s[1]);let o;for(o=0;o<W.length;o+=1){const H=pt(s,W,o);x[o]?x[o].p(H,E):(x[o]=yt(H),x[o].c(),x[o].m(le,null))}for(;o<x.length;o+=1)x[o].d(1);x.length=W.length}if(E&1){F=I(s[0]);let o;for(o=0;o<F.length;o+=1){const H=gt(s,F,o);C[o]?C[o].p(H,E):(C[o]=xt(H),C[o].c(),C[o].m(fe,null))}for(;o<C.length;o+=1)C[o].d(1);C.length=F.length}},i(s){he||(Lt(B.$$.fragment,s),he=!0)},o(s){Ft(B.$$.fragment,s),he=!1},d(s){s&&q(t),Et(B),pe(w,s),pe(y,s),pe(x,s),pe(C,s)}}}const $="/cse168-extra-credit";function Jt(e){return[[{desc:"<b>Custom Scene</b><br>Use <code>extra_credit_scene.txt</code> to view a custom scene built with cubemaps and reflections in mind.",img:"custom_scene.png"},{desc:"<b>Cubemaps</b>:<br>Press <code>c</code> to switch between cubemaps.",img:"cubemaps.png"},{desc:"<b>Keyframes</b>:<br>Press <code>space</code> in edit mode to add a keyframe, then <code>e</code> to exit edit mode and play back the animation.",img:"keyframes.gif"},{desc:"<b>Edit mode</b>:<br>Press <code>e</code> to enter edit mode, then <code>tab/shift+tab</code> to focus different objects in the scene.",img:"edit_mode.png"},{desc:"<b>Scene editing</b>:<br>Press <code>x/y/z</code> to select an axis, <code>t/r/s</code> to select an operation, and <code>up/down</code> to modify the current object.",img:"scene_editing.png"},{desc:"<b>Mouse orbit</b>:<br>Use the mouse to orbit the scene.",img:"mouse_orbit.png"},{desc:"<b>Reflections</b>:<br>Use the <code>reflectivity</code> command to specify how much of the cubemap an object reflects.",img:"reflections.png"},{desc:"<b>Textures</b>:<br>Press <code>n</code> when in edit mode to cycle between textures for each object.",img:"textures.png"}],[{desc:"<b>Real-time Editing</b><br>Construct curves in a 2D editing window and see them converted into 3D within an interactive viewing window.",img:"lathe.png"},{desc:"<b>Multiple Curves</b><br>Press <code>1/2/3</code> to add a new curve, and <code>C</code> to clear all curves.",img:"compound.png"},{desc:"<b>Vertex Normals</b><br>Each 3D object generates per-vertex normals, capable of smoothly reflecting a cubemap image.",img:"reflect.png"},{desc:"<b>Curve Coloring</b><br>Press <code>N</code> to change a single curve's color.",img:"color.png"}],[{desc:"<b>Main Assignment: High-Performance</b><br>Capable of rendering the Stanford dragon (100,000 triangles) at 4K resolution (3840x2160 pixels) in 1.7 seconds on an M1 Macbook Air.",img:"dragon_4k.png"},{desc:"<b>Main Assignment: Acceleration Structure</b><br>Computes a bounding volume hierarchy for fast intersection tests, reducing the time to render a scene with 100,000 triangles at 4K from 10 minutes to 1.7 seconds.",img:"acceleration.png"},{desc:"<b>Main Assignment: Multithreaded</b><br>Uses <code>std::thread</code> to render each scanline in a separate thread, improving performance by approximately 10x for sufficiently complex scenes.",img:"multithreaded.png"},{desc:"<b>Extra Credit: Real-Time</b><br>Capable of rendering directly to the terminal via ANSI escape sequences in real-time.",img:"realtime.png"},{desc:"<b>Extra Credit: Interactive</b><br>Click and drag the mouse to orbit around the scene to view it from different angles.",img:"interactive.png"},{desc:"<b>Extra Credit: Resizable</b><br>Re-run the program with the terminal at different zoom levels to view the scene at different resolutions.",img:"resolution.png"}],[{desc:"<b>Acceleration Structure</b><br>Computes a bounding volume hierarchy for fast intersection tests, reducing the time to render a scene with 100,000 triangles at 4K from 10 minutes to 1.7 seconds.",img:"acceleration.png"},{desc:"<b>.OBJ File Parsing</b><br>Use the <code>obj</code> command to add a Wavefront OBJ model to the scene, with support for models that supply their own vertex normals and texture coordinates.",img:"obj.png"},{desc:"<b>Texture Mapping</b><br>Use the <code>image</code> command to set the scene's background image, and the <code>texture</code> command to set the current object's texture using a PNG file.",img:"textures.png"},{desc:"<b>Area Lights/Soft Shadows</b><br>Use the <code>area</code> command to create an area light, which randomly samples shadow rays based on the <code>shadowsamples</code> command.",img:"soft_shadows.png"},{desc:"<b>Antialiasing</b><br>Use the <code>aasamples</code> command to adjust the number of jitter-sampled rays. The first ray is always shot through the center of each pixel.",img:"antialiasing.png"},{desc:"<b>Depth-of-Field</b><br>Modify <code>focallen, aperture,</code> and <code>dofsamples</code> to adjust the lens properties for randomly-sampled depth-of-field.",img:"dof.png"},{desc:"<b>Multithreading</b><br>Uses <code>std::thread</code> to render scanlines in separate threads, improving performance by approximately 10x for sufficiently complex scenes. Adjust the <code>threads</code> command to spawn a different number of threads.",img:"multithreaded.png"}]]}class Zt extends At{constructor(t){super(),kt(this,t,Jt,zt,St,{})}}new Zt({target:document.getElementById("app")});
